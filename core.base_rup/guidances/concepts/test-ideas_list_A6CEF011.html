<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="zh" xml:lang="zh">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>概念: 测试构想列表</title>
<meta content="Concept" name="uma.type">
<meta content="test-ideas_list" name="uma.name">
<meta content="测试构想列表" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_mp7z0DIDEdqwaNnSEheSAg", "_4EQgMDIEEdqwaNnSEheSAg", "_SPvXcN7IEdm8G6yT7-Wdqw", "{45219F27-0F84-4FD5-A7BC-73C19226303B}", "6.149711039531016E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_EOvXUN7HEdm8G6yT7-Wdqw", "_SPvXcN7IEdm8G6yT7-Wdqw", "{45219F27-0F84-4FD5-A7BC-73C19226303B}", "6.149711039531016E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_3lZjkCxqEdqYV4MWf8PiCw", "{45219F27-0F84-4FD5-A7BC-73C19226303B}", "6.149711039531016E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "6.149711039531016E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="6.149711039531016E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">概念：测试构想列表</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">测试构想列表是按重要性降序排列的测试构想的列表，这些测试构想和用于创建可执行测试的特定测试策略相关联。</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">关系</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">相关元素</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_ideas_list_2A0F8E03.html" guid="{45219F27-0F84-4FD5-A7BC-73C19226303B}">测试构想列表</a>
</li>
<li>
<a href="./../../../core.base_rup/tasks/identify_test_ideas_395DAB3B.html" guid="{6FAD9DF9-DE4E-4BA5-9B9B-482A2366D1B9}">确定测试构想</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">主要描述</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_test-ideas_list__concept_of" name="XE_test-ideas_list__concept_of" class="index" key="测试构想列表（test-ideas list）" text="概念"></a> 
<h3>
    <a id="Introduction" name="Introduction">简介</a>
</h3>
<p>
    用于设计测试的信息是从许多地方收集的：设计模型、分类器界面、状态表图和代码本身。在某个时刻，必须将此源文档信息转换为可执行的测试：
</p>
<ul>
    <li>
        为测试的软件提供的特定输入
    </li>
    <li>
        特定硬件和软件配置
    </li>
    <li>
        初始化到某个已知状态
    </li>
    <li>
        期望的特定结果
    </li>
</ul>
<p>
    直接从源文档信息转入可执行测试是可能的，但添加一个中间步骤通常是有用的。在此步骤中，<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_idea_6A36A957.html" target="_blank" guid="_yYDXsNnmEdmO6L4XMImrsA"><i>测试构想</i></a>被写入<i>测试构想列表</i>，该列表用于创建可执行测试。
</p>
<h3>
    <a id="TestIdeas" name="TestIdeas">什么是测试构想？</a>
</h3>
<p>
    测试构想（有时称为<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_requirement_E14A2712.html" target="_blank" guid="_yYNIudnmEdmO6L4XMImrsA">测试需求</a>）是关于可执行的测试的简短陈述。举一个简单的示例，让我们考虑一个计算平方根的函数，并提出某些测试构想：
</p>
<ul>
    <li>
        给出一个刚小于零的数字作为输入
    </li>
    <li>
        给出零作为输入
    </li>
    <li>
        测试完全平方的数字，如 4 或 16（结果恰是 2 或 4 吗？）
    </li>
</ul>
<p>
    每个意见都可以很容易地转换成具有精确的输入描述和期望结果的可执行测试。
</p>
<p>
    这种不甚具体的中间形式有两个好处：
</p>
<ul>
    <li>
        测试构想比完整测试更易复审、更易理解 － 更易理解测试背后的推理
    </li>
    <li>
        测试构想支持更有力的测试，如后面的标题<a href="#TestDesignUsingTheList">使用列表的测试设计</a>中所述
    </li>
</ul>
<p>
    平方根示例都描述输入，但测试构想可以描述可执行测试的任何元素。 例如，“打印到 LaserJet IIIp”描述了要用于测试的<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/test_environment_67E4FF5F.html" target="_blank" guid="_yX5mttnmEdmO6L4XMImrsA">测试环境</a>的一个方面，“使用完整数据库测试”也是如此，但是，这些后面的测试构想本身是非常不完整的：打印机将打印<b>什么</b>呢？要使用此完整的数据库做<b>什么</b>呢？不过，它们可确保重要的意见不被遗忘；在后面的测试设计中将更详细地描述这些意见。
</p>
<p>
    测试构想通常是基于<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/fault_model_C99EBECA.html" target="_blank" guid="_yJJZCdnmEdmO6L4XMImrsA"><i>错误模型</i></a>的；它们是对软件中哪些错误是似是而非的和如何最佳地揭示出那些错误的看法。例如，请考虑边界值。可以安全地假设平方根函数可以如下实施：
</p>
<blockquote>
<pre>
double sqrt(double x) {
    if (x &lt; 0)
      // signal error
    ...
</pre>
</blockquote>
<p>
    当 <b>&lt;</b> 被错误地输入成 <b>&lt;=</b> 时，它也似乎是正确的。人们经常犯该类型的错误，因此该错误是值得检查的。此错误不能用具有值 <b>2</b> 的 <b>X</b>
    检测到，因为错误表达式（<b>x&lt;=0</b>）和正确表达式（<b>x&lt;0</b>）将进入 <b>if</b> 语句的同一个分支。类似地，给定 <b>X</b> 的值为
    -<b>5</b>，则找不出此错误。找出它的唯一方法是给定 <b>X</b> 的值为 <b>0</b>，它会证明第二个测试构想。
</p>
<p>
    在本例中，错误模型是显式的。在其他案例中，它是隐式的。例如，只要程序操纵链接结构，就最好测试它是否为循环结构。多个错误导致错误地处理循环结构是有可能的。针对测试目的，不必枚举出这些错误 －
    了解某个值得运行测试的足够可能发生的错误就足够了。
</p>
<p>
    以下链接提供了关于从不同类型的错误模型中获取测试构想的信息。前两个是显式错误模型；最后一个使用隐式错误模型。
</p>
<ul>
    <li>
        <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_booleans_and_boundaries_74AE938C.html" guid="1.8659406802663404E-305">指南：关于布尔值和边界的测试构想</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_method_calls_B0A17E5C.html" guid="4.418859682485385E-305">指南：关于方法调用的测试构想</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-ideas_catalog_D99926DE.html" guid="6.368392607593696E-305">概念：测试构想目录</a>
    </li>
</ul>
<p>
    这些错误模型可以应用于多个不同工作产品。例如，第一个模型描述可利用布尔表达式做什么。可在代码、警戒条件、状态表图、时序图和方法行为的自然语言描述（如在已发布的 API 中）中找到这样的表达式。
</p>
<p>
    有时候，用于特定工作产品的指南也是有用的。请参阅<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/test_ideas_for_statechart_and_flow_diagrams_B881354C.html" guid="3.794638918140148E-305">指南：关于状态表图和流程图的测试构想</a>。
</p>
<p>
    特定的测试构想列表可能包含来自多个错误模型的测试构想，并且那些错误模型可从多个工作产品中派生。
</p>
<h3>
    <a id="TestDesignUsingTheList" name="TestDesignUsingTheList">使用列表的测试设计</a>
</h3>
<p>
    让我们假定您正在为搜索有序集合中的字符串的方法设计测试。在搜索中可以遵循或忽略大小写，并且返回找到的第一个匹配的索引或者 -1（如果未找到匹配）。
</p>
<blockquote>
<pre>
int Collection.find(String string,
            Boolean ignoreCase);
</pre>
</blockquote>
<p>
    这里是针对此方法的某些测试构想：
</p>
<ol>
    <li>
        在第一个位置找到匹配
    </li>
    <li>
        在最后一个位置找到匹配
    </li>
    <li>
        未找到匹配
    </li>
    <li>
        在集合中找到两个或多个匹配
    </li>
    <li>
        忽略大小写；找到匹配，但如果遵循大小写，则不是匹配
    </li>
    <li>
        遵循大小写；找到一个精确的匹配
    </li>
    <li>
        遵循大小写；跳过当忽略大小写时匹配的字符串
    </li>
</ol>
<p>
    实施这七个测试将是很简单的，每个测试针对一个测试构想。但是，不同的测试构想可合并到一个测试。例如，以下测试<i>符合</i>测试构想 2、6 和 7：
</p>
<blockquote>
    <p>
        设置：集合初始化为 ["dawn", "Dawn"]<br />
         调用：collection.find("Dawn", false)<br />
         期望结果：返回值是 1（如果“dawn”未跳过，值将为 0）
    </p>
</blockquote>
<p>
    提出非特定的测试构想会更容易进行合并。
</p>
<p>
    在三个测试中满足所有测试构想是可能的。为什么满足七个测试构想的三个测试比七个单独的测试要好呢？
</p>
<ul>
    <li>
        当创建大量单个测试时，通过复制第 N 个测试并进行调整使其刚好满足新的测试构想，来创建第 N+1 个测试是很常见的。结果是第 N+1 个测试与第 N
        个测试可能几乎是以同一种方式在执行程序（尤其是在更复杂的软件中）。它择取几乎完全相同的路径通过代码。<br />
        <br />
         而数量较少的测试（每个测试满足几个测试构想）不允许使用“复制并调整”方法。每个测试将与上一个有所不同，以不同的方式执行代码并择取不同的路径。<br />
        <br />
         为什么那样更好一些呢？如果测试构想列表是完整的，具有针对程序中的每个错误的测试构想，那么如何编写测试就无关紧要了。但是此列表始终缺少能查找错误的某些测试构想。通过让每个测试都做与上一个有很大不同的事情（通过添加看似不需要的种类），增加了其中一个测试将避开假象而发现一个错误的机会。实际上，更小型、更复杂的测试增加了测试将满足您未意识到需要的测试构想的机会。<br />
        <br />
    </li>
    <li>
        有时，当创建更复杂的测试时，新的测试构想浮现在脑海中。那通常不会在进行简单测试时发生，因为您已经进行了如此多的与上一个测试非常类似的测试，大脑已经变迟钝了。
    </li>
</ul>
<p>
    但是，出于一些原因，不创建复杂测试。
</p>
<ul>
    <li>
        如果每个测试都满足单个测试构想并且意见 2 的测试失败，那么您会立即知道最可能的原因：程序不在最后的位置上处理匹配。如果测试满足意见 2、6 和 7，那么隔离错误将会更难。<br />
        <br />
    </li>
    <li>
        复杂测试更难于理解和维护。测试的意图不够明显。<br />
        <br />
    </li>
    <li>
        复杂测试更难创建。构造一个满足五个测试构想的测试通常比构造五个各自满足一个测试构想的测试要花费更多时间。而且，更易犯错误 － 考虑应满足所有五个意见，而实际只满足了四个的情况。
    </li>
</ul>
<p>
    在实践中，必须在复杂和简单之间找到一个合理的平衡点。例如，施加于软件的最初的测试（通常称为<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/smoke_test_961BBC4D.html" target="_blank" guid="_yVhBFtnmEdmO6L4XMImrsA"><i>冒烟测试</i></a>）应是简单、易于理解和维护的，并且旨在捕获最明显的问题。后来的测试应更加复杂，但也不能复杂到无法维护。
</p>
<p>
    在完成一组测试之后，最好针对<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/developer_testing_D800236F.html#TestDesignMistakes" guid="7.256588791264849E-307">概念：开发人员测试</a>中讨论的特征测试设计错误进行检查。
</p>
<h3>
    <a id="UsingTestIdeasBeforeTest" name="UsingTestIdeasBeforeTest">在测试之前使用测试构想</a>
</h3>
<p>
    测试构想列表有助于复审和检查设计工作产品。例如，考虑显示部门和员工类之间的关联的这部分<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_model_BAFECB4C.html" target="_blank" guid="_yF4CltnmEdmO6L4XMImrsA">设计模型</a>。
</p>
<p align="center">
    <img height="45" alt="设计模型示例图" src="./../../../core.base_rup/guidances/concepts/resources/tstidslst-img1.gif" width="223" />
</p>
<p class="picturetext">
    图 1：部门和员工类之间的关联
</p>
<p>
    从这样一个模型中创建测试构想的规则将让您考虑部门中有多个员工的情况。通过浏览整个设计并询问“如果此刻该部门有多个员工，会怎么样呢？”，您可能会发现设计或分析错误。例如，您可能会意识到在部门之间每次只能调动一个员工。如果企业倾向于彻底重组，需要调动许多员工，那么这可能是一个问题。
</p>
<p>
    忽略了可能性的此类错误、案例被称为<i>忽略的错误</i>。正像错误本身一样，您也许会在测试工作中忽略检测这些错误的测试。例如，请参阅 <a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#GLA81" guid="7.755968586980351E-308">[GLA81]</a>、<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#OST84" guid="7.755968586980351E-308">[OST84]</a>、<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#BAS87" guid="7.755968586980351E-308">[BAS87]</a>和<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#MAR00" guid="7.755968586980351E-308">[MAR00]</a>，以及显示部署中错误忽略频率的其他研究。
</p>
<p>
    测试在设计活动中的角色在<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/test-first_design_6124EA6D.html" guid="2.5962561793181055E-305">概念：测试优先设计</a>中进一步讨论。
</p>
<h3>
    <a id="TestIdeasTraceability" name="TestIdeasTraceability">测试构想和可跟踪性</a>
</h3>
<p>
    <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/traceability_84090089.html" target="_blank" guid="_yY8vkNnmEdmO6L4XMImrsA">可跟踪性</a>是权衡的问题。它的价值值得为维护它而花费成本吗？在<img alt="" src="./../../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../../pages_not_installed/pages_not_installed.html" guid="{F6F9BB36-5A72-421E-B195-8937E0C46AF8}">任务：定义评估和可跟踪性需求</a>期间需要考虑此问题。
</p>
<p>
    当可跟踪性是值得的时，按照惯例将跟踪测试直至回到激发它们的工作产品。例如，您可以在 API 和它的测试之间保持可跟踪性。如果 API 发生变更，您就会知道要变更哪些测试。 如果代码（用于实施
    API）发生变更，您也会知道要运行哪些测试。如果测试令您迷惑不解，可以查找它希望测试的 API。
</p>
<p>
    测试构想列表增加了另一个可跟踪性级别。可以从测试跟踪到其满足的测试构想，然后从测试构想跟踪到初始工作产品。
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;All Rights Reserved.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
