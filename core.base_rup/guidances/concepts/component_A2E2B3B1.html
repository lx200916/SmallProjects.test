<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="zh" xml:lang="zh">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>概念: 组件</title>
<meta content="Concept" name="uma.type">
<meta content="component" name="uma.name">
<meta content="组件" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_IY0NkAISEdqTna4sZVFRow", "_ydt62NnmEdmO6L4XMImrsA", "3.524150980437479E-305"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_QV4x0AISEdqTna4sZVFRow", "_kjFBYN7HEdm8G6yT7-Wdqw", "{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}", "3.524150980437479E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_kC0pcN7GEdm8G6yT7-Wdqw", "_ydt62NnmEdmO6L4XMImrsA", "3.524150980437479E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_EOvXUN7HEdm8G6yT7-Wdqw", "_kjFBYN7HEdm8G6yT7-Wdqw", "{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}", "3.524150980437479E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_mTMIkN7REdmjRZts2c4ZjQ", "{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}", "3.524150980437479E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "3.524150980437479E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="3.524150980437479E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">概念：组件</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">组件是系统的封装部分，理论上是系统中相当重要的、几乎独立的可替换部分，它在明确定义的体系结构环境中实现明确的功能。</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">关系</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">相关元素</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/disciplines/rup_analysis_design_discipline_29760231.html" guid="_ydt62NnmEdmO6L4XMImrsA">分析和设计</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">设计模型</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">主要描述</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_component__concepts" name="XE_component__concepts"></a> 
<h3>
    <b><a id="Introduction" name="Introduction">定义</a></b>
</h3>
<p>
    软件行业和文献中使用术语“组件”来指许多不同的事物。它通常用来泛指“构成其他事物的部分”。它还常用来特指使得能在较大系统中进行替换和装配的特定特征。
</p>
<p>
    在 RUP 中，我们使用术语“组件”来表示系统的封装部分，理论上是系统中相当重要的、几乎独立的可替换部分，它在明确定义的体系结构环境中实现明确的功能。这包括：
</p>
<ul>
    <li>
        设计组件 － 重要的设计封装部分，因此包含设计子系统，有时还包含重要的设计类和设计包。
    </li>
    <li>
        实施组件 － 重要的实施封装部分，通常是实施设计组件的代码。
    </li>
</ul>
<p>
    理论上，设计应反映实施，因此您可以只引用组件，每个组件均具有设计和实施。
</p>
<p>
    UML（[<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04" guid="7.755968586980351E-308">UML04</a>]）如下定义了“组件”：
</p>
<blockquote>
    <p>
        封装了内容的系统模块化部分，其表现形式在环境中是可替换的。 组件在提供的接口和必需的接口方面定义自己的行为。 这样，组件充当一个类型，其一致性由这些提供的和必需的接口定义（包含它们静态和动态的语义）。
    </p>
</blockquote>
<p>
    组件被定义为结构化类的子类型，这样，组件就具有属性和操作，能够参与关联关系和泛化关系，并具有内部的结构和端口。 请参阅<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">概念：结构化类</a>以获取更多详细信息。
</p>
<p>
    存在许多适用于组件的 UML 标准构造型，例如用来为大规模组件建模的 &lt;&lt;subsystem&gt;&gt;，以及用来为具有明确规范和实现定义（其中一个规范可以有多个实现）的组件建模的
    &lt;&lt;specification&gt;&gt; 和 &lt;&lt;realization&gt;&gt;。
</p>
<p>
    在 RUP 中，术语“组件”的使用要比 UML 的定义广泛。我们并不是仅仅将组件定义为具有诸如模块性、可部署性和可替换性之类的特征，而是建议组件应该具有这些特征。 关于组件可替换性，请参阅下面的部分。
</p>
<h3>
    <b><a id="Component_Replaceability" name="Component_Replaceability">组件可替换性</a></b>
</h3>
<p>
    在 RUP 和 UML 术语中，组件应是可替换的。不过，这可能仅仅意味着组件公开了一组隐藏底层实施的接口。
</p>
<p>
    存在其他更强的可替换性类型。它们在下面列出。
</p>
<h4>
    源文件可替换性
</h4>
<p>
    如果在单个源代码文件内实施两个类，则通常不能分别地为两个编排版本并控制这两个类。
</p>
<p>
    不过，如果一组文件完全实施单个组件，而不实施任何其他组件，那么该组件即为“源文件可替换”。 此特征使得更容易对组件源代码进行版本控制、设置基线以及重用。
</p>
<h4>
    部署可替换性
</h4>
<p>
    如果两个类在单个可执行文件中部署，那么每个类在已部署的系统中不能独立地替换。
</p>
<p>
    对较大粒度组件期望的特征是“部署可替换”，从而允许部署组件的新版本而无需重新构建其他组件。这通常意味着存在一个文件或一组文件来部署该组件而不部署任何其他组件。
</p>
<h4>
    运行时可替换性
</h4>
<p>
    如果某个组件可以重新部署到正在运行的系统中，则称为“运行时可替换”。这使得软件能在不损失可用性的情况下进行升级。
</p>
<h4>
    位置透明性
</h4>
<p>
    具有网络可寻址接口的组件可称为具有“位置透明性”。这使得组件能重新定位到其他服务器，或在多台服务器上复制，以支持故障容忍和负载均衡等等。 这些类型的组件通常称为“分布式”组件或“可分布”组件。
</p>
<h3>
    <b><a id="Component_Modeling" name="Component_Modeling">组件的建模</a></b>
</h3>
<p>
    UML 组件是一个建模结构，它提供以下能力：
</p>
<ul>
    <li>
        能对类进行分组以定义较大粒度的系统部件
    </li>
    <li>
        能分离可视界面和内部实施
    </li>
    <li>
        能拥有在运行时执行的实例
    </li>
</ul>
<p>
    组件有许多提供的和必需的接口，它们组成了将组件串在一起的基础。 提供的接口是直接由组件实施或者由它的实现类或子组件之一实施的接口，或者是提供的组件端口的类型。
    必需的接口由来自组件或者其实现类或子组件的用途依赖关系指定，或者是必需端口的类型。
</p>
<p>
    组件具有借助于公开可见的属性和操作的外部视图（或称为“黑匣”视图）。
    （可选）诸如协议状态机之类的行为可以连接到接口、端口以及组件本身，以通过使操作调用序列中的动态约束明确化，来更精确地定义外部视图。组件在系统中或其他环境中的串连可以通过使用组件接口之间的依赖关系来进行结构定义（通常是在组件图上）。
</p>
<p>
    （可选）可以通过在组合结构中使用部件和连接器，来制定更详细的结构协作规范，从而指定组件之间的角色或实例级别协作。 这是组件的内部视图（或称为“白匣”视图），它借助于组件的专用属性，以及实现类或子组件。该视图显示如何内部地实现外部行为。
    外部和内部视图之间的映射通过依赖关系完成（在组件图上），或者通过向内部部件委托连接器完成（在组合结构图上）。
</p>
<p>
    RUP 建议将组件用作设计子系统的表示方法。关于详细信息，请参阅<a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html" guid="{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}">工作产品：设计子系统</a>、<a class="elementLinkWithUserText" href="./../../../core.base_rup/tasks/subsystem_design_5D1BCC0C.html" guid="{CAA385CA-2BA2-40F2-8FE3-E21089D02119}">任务：子系统设计</a>和<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html" guid="1.2314266786534317E-305">指南：设计子系统</a>。另请参阅<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">概念：结构化类</a>中的定义。
</p>
<h3>
    <b><a id="Component_Instantiation" name="Component_Instantiation">组件实例化</a></b>
</h3>
<p>
    对于是否在运行时直接实例化组件，没有明确要求。
</p>
<p>
    间接实例化的组件通过一组类、子组件或部件实施或实现。组件本身不出现在实施中，它充当实施必须遵循的设计方案。 实现类、子组件或部件的集合必须涵盖在组件提供的接口中指定的整个操作集。实施组件的方式是实施者的职责。
</p>
<p>
    直接实例化的组件指定其自己的封装实施，它作为可寻址的对象进行实例化。这意味着设计组件在实施语言中具有相应的构造，因此能明确地引用。
</p>
<h3>
    <b><a id="UML_1x_Representation" name="UML_1x_Representation">UML 1.x 表示</a></b>
</h3>
<p>
    UML 1.5 如下定义了“组件”：
</p>
<blockquote>
    <p>
        系统中模块化的、可部署且可替换的部分，它封装实施，并暴露一组接口。 组件通常由一个或多个驻留在它上面的类或子组件指定，并可以由一个或多个工件（例如二进制文件、可执行文件或脚本文件）实施。
    </p>
</blockquote>
<p>
    请注意，在 UML 1.3 及更早的 UML 版本中，“组件”表示法用来表示实施中的文件。而在最新的 UML 定义中，文件不再视为“组件”。不过，许多工具和 UML 概要文件仍使用组件表示法来表示文件。请参阅<img alt="" src="./../../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../../pages_not_installed/pages_not_installed.html" guid="1.0315418523886092E-305">指南：实施元素</a>以获取更多关于在 UML 中表示文件的讨论。
</p>
<p>
    从建模角度来说，组件可与 UML 1.5 中的 UML 子系统相比，因为它们都提供模块性、封装以及能在运行时执行的实例。 RUP 将 UML 1.5 组件建模构造视为表示设计子系统的替代表示法。 关于详细信息，请参阅<a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html" guid="{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}">工作产品：设计子系统</a>和<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html" guid="1.2314266786534317E-305">指南：设计子系统</a>。<br />
    <br />
     关于更多信息，请参阅<a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html" guid="4.792914878943572E-306">UML1.x 和 UML 2.0 之间的区别</a>。
</p></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;All Rights Reserved.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
