<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="zh" xml:lang="zh">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>任务描述符: 类设计</title>
<meta content="TaskDescriptor" name="uma.type">
<meta content="class_design" name="uma.name">
<meta content="类设计" name="uma.presentationName">
<meta content="_p-f_sEocEdqrjq4i3fchvA" name="uma.guid">
<meta content="TaskDescriptor" name="element_type">
<meta content="description" name="filetype">
<meta name="role" content="设计人员">
<link type="text/css" href="./../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ActivityTreeTable.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ProcessElementPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/processElementData.js"></script><script language="JavaScript" type="text/javascript">
					var defaultQueryStr = '?proc={002674F9-6511-4D15-8623-B761D8C48986}&path={002674F9-6511-4D15-8623-B761D8C48986},{9C683674-97C1-4AEE-8DB0-9514AEFF698E},_p-f_sEocEdqrjq4i3fchvA';
					var backPath = './../../';
					var imgPath = './../../images/';
					var nodeInfo=[{view: "view:_e_O28N7KEdm8G6yT7-Wdqw", path: ["_e_O28N7KEdm8G6yT7-Wdqw", "_vCtak0JHEdq4z9xc-r201w", "_vChNQkJHEdq4z9xc-r201w", "_vChNREJHEdq4z9xc-r201w", "_XSr4YCFtEdqrX8YVzvtlIg", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_e_O28N7KEdm8G6yT7-Wdqw", path: ["_e_O28N7KEdm8G6yT7-Wdqw", "_vCtak0JHEdq4z9xc-r201w", "_vCtajUJHEdq4z9xc-r201w", "_vCtai0JHEdq4z9xc-r201w", "_J1u8gCGYEdqMcovRzkCQow", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_e_O28N7KEdm8G6yT7-Wdqw", path: ["_e_O28N7KEdm8G6yT7-Wdqw", "_vCtak0JHEdq4z9xc-r201w", "_vCtaj0JHEdq4z9xc-r201w", "_vCtakkJHEdq4z9xc-r201w", "_rw4S4Z5IEdq7s5zuJVEAAw", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_PEpmMCVuEdqSZ9OimJ-AzA", "_-kFhcCVuEdqSZ9OimJ-AzA", "_pV4NgSFsEdqrX8YVzvtlIg", "_XSr4YCFtEdqrX8YVzvtlIg", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_PEpmMCVuEdqSZ9OimJ-AzA", "_SkuIwCVwEdqSZ9OimJ-AzA", "_gM9X0CGFEdqMcovRzkCQow", "_J1u8gCGYEdqMcovRzkCQow", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_PEpmMCVuEdqSZ9OimJ-AzA", "_cn2akCVwEdqSZ9OimJ-AzA", "_zUDkgSGFEdqMcovRzkCQow", "_vllcADIKEdqGgPtrSpB0vQ", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_e_O28N7KEdm8G6yT7-Wdqw", "_vCtak0JHEdq4z9xc-r201w", "_vChNQkJHEdq4z9xc-r201w", "_vChNREJHEdq4z9xc-r201w", "_XSr4YCFtEdqrX8YVzvtlIg", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_e_O28N7KEdm8G6yT7-Wdqw", "_vCtak0JHEdq4z9xc-r201w", "_vCtajUJHEdq4z9xc-r201w", "_vCtai0JHEdq4z9xc-r201w", "_J1u8gCGYEdqMcovRzkCQow", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_e_O28N7KEdm8G6yT7-Wdqw", "_vCtak0JHEdq4z9xc-r201w", "_vCtaj0JHEdq4z9xc-r201w", "_vCtakkJHEdq4z9xc-r201w", "_rw4S4Z5IEdq7s5zuJVEAAw", "_RP00kCCdEdq3qtLcbHn6PQ", "_p-f_sEocEdqrjq4i3fchvA"]}];
					contentPage.preload(imgPath, backPath, nodeInfo, defaultQueryStr, true, true, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top">
<div id="page-guid" value="_p-f_sEocEdqrjq4i3fchvA"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">任务：类设计</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../images/taskdes_lg_dgm32.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">此任务定义了如何设计子系统或组件的类结构。</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">用途</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_class__designing" name="XE_class__designing"></a> 
<ul>
    <li>
        确保类能提供用例实现所要求的行为
    </li>
    <li>
        确保能提供足够的信息来明确地实施类
    </li>
    <li>
        处理与类相关的非功能需求
    </li>
    <li>
        合并类使用的设计机制
    </li>
</ul></td>
</tr>
</table>
</div>
<div class="sectionHeading">关系</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">角色</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">主要:
							</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_designer_FCD65796.html" guid="_CQ1sARi2Edq_uI8xTPML6g">设计人员</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">其他:
							</span></td><td class="sectionTableCell"><span class="sectionTableCellHeading">辅助:
							</span></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">输入</th><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">必需:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_2AF5CBCB.html" guid="_lPfDIb9dEdqBwpaAk4N49g">分析类</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_analysis_class_5AF5E1CC.html" guid="_me4OcL9dEdqBwpaAk4N49g">分析类</a>
</li>
</ul>
</td><td width="30%" class="sectionTableCell"><span class="sectionTableCellHeading">可选:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_supplementary_specification_BA9F2DDB.html" guid="_CQ1sBxi2Edq_uI8xTPML6g">补充规范</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_storyboard_505ECF16.html" guid="_p-sM8EocEdqrjq4i3fchvA">故事板</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_7D6F5DFE.html" guid="_CQ7yohi2Edq_uI8xTPML6g">设计模型</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_user_interface_prototype_F60D4BBC.html" guid="_CQ1sAxi2Edq_uI8xTPML6g">用户界面原型</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">外部:
								</span>
<ul>
<li>无</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">输出</th><td colspan="3" class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/rup_design_model_7D6F5DFE.html" guid="_CQ7yohi2Edq_uI8xTPML6g">设计模型</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">主要描述</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><p>
    类是设计工作的重要部分 － 它们实际上执行系统的真正工作。其他设计元素（如子系统、程序包和协作）描述类如何分组以及如何互相操作。
</p>
<p class="reactive">
    封装体也是定型的类，用于代表实时系统中的执行的并发线程。在这样的情况下，其他设计类是被动类，在主动封装体提供的执行环境内使用。当软件设计人员和设计人员选择不使用基于封装体的设计方法时，还是有可能用活动类对并发行为建模。
</p>
<p>
    活动类是协调并推动被动类行为的设计类 － 活动类是这样的类：其实例是拥有自己的控制线程的活动对象。
</p></td>
</tr>
</table>
</div>
<div class="sectionHeading">步骤</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr>
<td class="sectionTableCell">
<div class="stepHeading"> 使用设计模式和机制</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_patterns__using" name="XE_patterns__using" class="index" key="模式（patterns）" text="使用模式"></a><a id="XE_mechanisms__using" name="XE_mechanisms__using" class="index" key="机制（mechanisms）" text="使用机制"></a><a id="Use Design Patterns and Mechanisms" name="Use Design Patterns and Mechanisms"></a>
<p>
    使用适合设计的类或功能、符合项目设计指南的设计模式和机制。
</p>
<p>
    合并模式和／或机制能有效地执行此任务中的许多后续步骤（添加新类、操作、属性和关系），但是要符合模式或机制定义的规则。
</p>
<p>
    请注意，模式和机制一般随着设计的发展而合并，不只是作为此任务中的第一步。它们还经常在一组类中得到应用，而不仅仅应用于单个类。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 创建初始设计类</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_class__creating_design_classes_initially" name="XE_class__creating_design_classes_initially" class="index" key="类（class）" text="设计"></a><a id="Create Initial Design Classes" name="Create Initial Design Classes"></a>
<p>
    为指定为此任务输入的分析类创建一个或多个初始设计类，并指定跟踪依赖关系。本步骤中创建的设计类将在后续步骤中得到优化、调整、拆分或合并；在后续的步骤中将指定各种描述分析类如何设计的设计属性 － 如操作、方法和状态机。
</p>
<p>
    根据设计的分析类的类型（边界、实体或控制），您可以使用特定的策略创建初始设计类。
</p>
<h4>
    <a id="XE_boundary_class__designing" name="XE_boundary_class__designing" class="index" key="边界类（boundary class）" text="设计"></a><a id="Designing boundary classes" name="Designing boundary classes">设计边界类</a>
</h4>
<p>
    边界类代表到用户或其他系统的接口。
</p>
<p>
    一般情况下，代表到其他系统的接口的边界类被建模为子系统，因为它们往往有复杂的内部行为。如果接口行为很简单（也许只是充当到外部系统的现有 API 的传递），那么您可能会选择用一个或多个设计类代表接口。如果您选择这种方式，请对每个协议、接口或
    API 使用单个的设计类，并记录关于您在类的特别需求中使用的标准的特别需求。
</p>
<p>
    代表到用户的接口的边界类一般遵循用户界面中的每个窗口对应一个边界类或每种形式对应一个边界类的规则。结果，边界类的职责就可能处于一个相当高的级别，并需要在本步骤中进行优化和详细说明。用户界面的其他模型或原型可能是本步骤中要考虑的另一个输入来源。
</p>
<p>
    边界类的设计取决于项目可用的用户界面（UI）开发工具。使用当前的技术，在开发工具中直接直观地构造 UI 是很常见的。这将自动创建需要与控制和实体类的设计相关的 UI 类。如果 UI 开发环境自动创建实施 UI
    所需的支持类，那么就没有必要在设计中考虑这些支持类了。您只设计开发环境没有为您创建的内容。
</p>
<h4>
    <a id="XE_entity_class__designing" name="XE_entity_class__designing" class="index" key="实体类（entity class）" text="设计"></a><a id="Designing Entity Classes" name="Designing Entity Classes">设计实体类</a>
</h4>
<p>
    在分析期间，实体类代表被操纵的信息单元。 它们往往是被动的、持久的，并且可能被确定并与持久性分析机制相关联。关于设计基于数据库的持久性机制的详细信息包含在<a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/database_design_8552DD3.html" guid="{2E74A414-49F5-4F27-BFCB-AA2DAC675F58}">任务：数据库设计</a>中。性能考虑事项可能会迫使持久类的一定重构，从而造成在<a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">角色：数据库设计人员</a>和<a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">角色：设计人员</a>之间联合讨论的“设计模型”的更改。
</p>
<p>
    有关持久类的设计问题的更广泛的讨论展示在后面题为<a href="#Define Persistent Classes">确定持久类</a>的部分中。
</p>
<h4>
    <a id="XE_control_class__designing" name="XE_control_class__designing" class="index" key="控制类（control class）" text="设计"></a><a id="Designing Control Classes" name="Designing Control Classes">设计控制类</a>
</h4>
<p>
    控制对象负责管理用例的流动并因此协调其大多数操作；控制对象封装的逻辑不是特别与用户界面问题（边界对象）或数据工程问题（实体对象）相关。这种逻辑有时称为<b>应用逻辑</b>或<b>业务逻辑</b>。
</p>
<p>
    在设计控制类时请考虑下列问题：
</p>
<ul>
    <li>
        <b>复杂性</b> － 您可以用边界类或实体类处理不复杂的控制或协调行为。然而，随着应用变得越来越复杂，该方法的重大缺点也逐渐显露出来，例如：
    </li>
</ul>
<blockquote>
    <ul>
        <li>
            用例协调行为嵌入到了 UI 中，这使更改系统变得更加困难
        </li>
        <li>
            相同的 UI 不能简单地在不同的用例实现中使用
        </li>
        <li>
            UI 因为增加了功能而增加负担，结果降低了性能
        </li>
        <li>
            实体对象可能因为用例特定的行为而增加负担，结果降低了其泛化程度
        </li>
    </ul>
</blockquote>
<blockquote>
    <p>
        为了避免这些问题的发生，就引进了控制类来提供与协调事件流相关的行为。
    </p>
</blockquote>
<ul>
    <li>
        <b>更改可能性</b> － 如果更改事件流的可能性很低或者成本可以忽略不计，那么其他控制类的额外开支和复杂性就可能没有正当的支持理由。
    </li>
    <li>
        <b>分发和性能</b> － 在不同节点上或在不同流程空间中运行部分应用程序的需要产生了将设计模型元素专门化的需要。这种专门化往往通过添加控制对象并将来自边界和实体类的行为分发到控制类来完成。在执行这一操作期间，边界类朝着提供纯
        UI 服务移动，实体类朝着提供纯数据服务移动，而控制类则提供剩余部分。
    </li>
    <li>
        <b>事务管理</b> － 管理事务是典型的协调活动。因为缺乏处理事务管理的框架，需要一个或多个<b>事务管理器</b>类进行交互，以确保您能保持事务的完整性。
    </li>
</ul>
<p>
    在后两种情况下，如果控制类代表独立的控制线程，那么使用活动类来对控制线程建模可能会更加适合。在实时系统中，使用<img alt="" src="./../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../pages_not_installed/pages_not_installed.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">工作产品：封装体</a>是较为合适的建模方法。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 确定持久类</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_persistent_class__identifying" name="XE_persistent_class__identifying" class="index" key="持久类（persistent class）" text="确定"></a><a id="XE_entity_class__define_persistent_classes" name="XE_entity_class__define_persistent_classes"></a><a id="Define Persistent Classes" name="Define Persistent Classes"></a>
<p>
    需要在永久介质上存储其状态的类被称为持久类。存储状态的需要可能是为了永久记录类信息、作为出现系统故障时的备份或用于信息的交换。持久类可能既有持久实例，也有临时实例；将类标注为持久只意味着类的某些实例可能需要持久。
</p>
<p>
    根据在分析期间找到的持久性机制来合并设计机制。例如，根据类的要求，持久性的分析机制可能通过以下设计机制中的一个来实现：
</p>
<ul>
    <li>
        内存存储
    </li>
    <li>
        闪存卡
    </li>
    <li>
        二进制文件
    </li>
    <li>
        数据库管理系统（DBMS）
    </li>
</ul>
<p>
    持久对象可能不仅仅从实体类获得；持久对象还可能需要用来处理一般的非功能需求。示例有：维护与流程控制相关的信息或者维护事务之间的状态信息需要持久对象。
</p>
<p>
    确定持久类用来通知<a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">角色：数据库设计人员</a>：类要求对其物理存储特征有特别关注。它还通知<a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_software_architect_DB0BF177.html" guid="{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}">角色：软件设计人员</a>类需要是持久类，并通知负责持久性机制的<a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">角色：设计人员</a>类的实例需要变为持久实例。
</p>
<p>
    由于需要协调的持久性策略，<a class="elementLinkWithUserText" href="./../../core.base_rup/roles/rup_database_designer_524DC34F.html" guid="{87EE3BF5-17CA-4211-BD3D-32F361E58550}">角色：数据库设计人员</a>就负责用持久性框架将持久类映射到数据库。如果项目开发的是持久性框架，则框架开发人员还将负责了解设计类的持久性需求。要向这些人员提供他们所需的信息，此时表明类是持久的，或者（更精确地说）表明类的实例是持久的就足够了。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义类的可视性</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Class Visibility" name="Define Class Visibility"></a>
<p>
    对于每个类，请确定它所在程序包内的类可视性。<i>公用</i>类可以在包含程序包的外部引用。<i>私有</i>类（或可视性为<i>实施</i>的类）只能由同一个包内的类引用。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义操作</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_operation__defining_on_classes" name="XE_operation__defining_on_classes" class="index" key="操作（operation）" text="在类中定义"></a><a id="Define Operations" name="Define Operations"></a>
<ul>
    <li>
        <a href="#Identifying operations">确定操作</a>
    </li>
    <li>
        <a href="#Naming and describing the operations">命名并描述操作</a>
    </li>
    <li>
        <a href="#Defining operation visibility">定义操作可视性</a>
    </li>
    <li>
        <a href="#Defining class operations">定义类操作</a>
    </li>
</ul>
<h4>
    <a id="Identifying operations" name="Identifying operations">确定操作</a>
</h4>
<p>
    要在设计类上确定操作：
</p>
<ul>
    <li>
        研究每个相对应的分析类的职责，为每个职责创建一个操作。将职责的描述用作操作的初始描述。
    </li>
    <li>
        研究类 <i>participates</i> 中的用例实现，查看操作如何由用例实现使用。扩展操作，此时为一个用例实现，优化操作、操作的描述、返回类型以及参数。与类相关的每个用例实现的需求都在用例实现的“事件流”中有文字描述。
    </li>
    <li>
        研究“特别需求”用例，确保您没有遗漏可能在那里有陈述的操作的隐含需求。
    </li>
</ul>
<p>
    要求操作能支持出现在时序图上的消息，因为脚本 － 尚未分配给操作的临时消息规范 － 描述期望类能执行的行为。图 1 是时序图的一个示例。
</p>
<p align="center">
    <img src="./../../core.base_rup/guidances/guidelines/resources/seqdiag1.gif" width="672" height="417" alt="附带文本中描述的图。" />
</p>
<p class="picturetext" align="center">
    图 1：消息成为确定操作的基础
</p>
<p>
    用例实现不能提供足够的信息来确定所有操作。要查找剩下的操作，请考虑下列问题：
</p>
<ul>
    <li>
        有没有将类的新实例初始化的方法（包括将其连接到它所关联的其他类的实例）？
    </li>
    <li>
        有没有必要进行测试来查看类的两个实例是否相等？
    </li>
    <li>
        有没有必要创建类实例的副本？
    </li>
    <li>
        机制使用的类上有没有要求任何操作？例如，<i>垃圾回收</i>机制可能要求对象能够释放它对所有其他对象的所有引用，以便释放所有不再使用的资源。
    </li>
</ul>
<p>
    不要定义仅仅获得并设置公用属性的值的操作（请参阅<a href="#Define Attributes">定义属性</a>和<a href="#Define Associations">定义关联</a>）。通常来讲，这些是由代码生成工具生产的，不要求进行显式的定义。
</p>
<h4>
    <a id="XE_operation__naming" name="XE_operation__naming"></a><a id="Naming and describing the operations" name="Naming and describing the operations">命名并描述操作</a>
</h4>
<p>
    命名操作、返回类型以及参数和它们的类型时，请使用实施语言的命名约定。这些在<img alt="" src="./../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../pages_not_installed/pages_not_installed.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">特定于项目的指南</a>中有描述。
</p>
<p>
    对于每个操作，您都应该定义以下内容：
</p>
<ul>
    <li>
        <b>操作名称</b> － 使名称简短并能描述操作实现的结果。 
        <ul>
            <li>
                操作的名称应该遵循实施语言的语法。例如：C++ 或 Visual Basic 可以接受 <b>find_location</b>，但 Smalltalk 则不能（其中不能使用下划线）；能用于所有语言的更好的名称是
                <b>findLocation</b>。
            </li>
            <li>
                请避免使用暗示操作如何执行的名称。例如，<b>Employee.wages()</b> 比 <b>Employee.calculateWages()</b>
                要好，因为后者暗示要执行计算操作。操作可能只返回数据库中的一个值。
            </li>
            <li>
                操作的名称应该清楚地表明其目的。请避免使用不具体的、不描述它们返回的结果的名称，例如 <b>getData</b>。请使用能确切显示期望内容的名称，例如
                <b>getAddress</b>。更好的方法是，只要让操作名称是返回或设置的属性的名称就可以了。如果它有参数，它就设置属性。如果它没有参数，它就获取属性。示例：操作 <b>address</b>
                返回<b>客户</b>的地址，而 <b>address(aString)</b> 则设置或更改<b>客户</b> 的地址。该操作的 <i>get</i> 和 <i>set</i> 本质是操作的特征符中所隐含的。
            </li>
            <li>
                概念上相同的操作应该有相同的名称，即使定义它们的类不同、即使它们用完全不同的方法实施或者即使它们的参数数量不同也一样。例如，创建对象的操作的名称应该在所有类中都相同。
            </li>
            <li>
                如果数个类中的操作有相同的特征符，则操作必须返回适合于接收者对象的同种结果。这是<b>多态性</b>概念的一个示例，即不同的对象应该用类似的方法响应相同的消息。示例：操作 <b>name</b>
                应该返回对象的名称，而不管名称如何存储或如何得到。遵循这种原则会使模型较易理解。
            </li>
        </ul>
    </li>
    <li>
        <b>返回类型</b> － 返回类型应该是操作返回的对象的类。
    </li>
    <li>
        <b>简短描述</b> － 虽然您尽量使操作的名称有意义，但是在尝试了解操作所做的事情时，操作的名称往往只能起很模糊的指示作用。从操作<b>用户</b>角度简短地描述操作，由几个句子组成。
    </li>
    <li>
        <b>参数</b> －
        对于每个参数，请创建一个简短的描述性名称，确定它的类并给它一个简短的描述。在指定参数时，请记住参数越少，可重用性就越高。较少的参数使操作更容易理解，因此更可能找到类似的操作。您可能需要将有很多参数的操作分为数个操作。操作对于那些要使用它的人必须是可以理解的。简短描述应该包含：
        <ul>
            <li>
                参数的意义（如果名称中不明显）
            </li>
            <li>
                参数是<b>通过值</b>传递，还是<b>通过引用</b>传递
            </li>
            <li>
                必须提供值的参数
            </li>
            <li>
                可以选择的参数以及它们的缺省值（如果未提供值）
            </li>
            <li>
                参数的有效范围（如果适用）
            </li>
            <li>
                操作中做什么事情
            </li>
            <li>
                操作更改了哪些<b>通过引用</b>传递的参数
            </li>
        </ul>
    </li>
</ul>
<p align="left">
    一旦定义了操作，就请用关于每条消息调用了什么操作的信息来完成时序图。
</p>
<p align="left">
    有关更多信息，请参阅题为<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_class_E98280BF.html#Class Operations" guid="2.914882084937444E-305">工作产品指南：设计类</a>的部分。
</p>
<h4 align="left">
    <a id="Defining operation visibility" name="Defining operation visibility">定义操作可视性</a>
</h4>
<p align="left">
    对于每个操作，请从下列选项确定操作的导出可视性：
</p>
<ul>
    <li>
        <b>公用</b> － 操作对于类本身以外的模型元素是可视的。
    </li>
    <li>
        <b>实施</b> － 操作只在类本身内可视。
    </li>
    <li>
        <b>受保护</b> － 该操作仅对类自身、其子类或<i>友元</i>（取决于语言）可视。
    </li>
    <li>
        <b>私有</b> － 操作仅对于类本身以及类的<i>友元</i>可视。
    </li>
</ul>
<p>
    请选择可能最受限制、但仍能实现操作目标的可视性。
    为此，请查看时序图，对于每条消息，确定消息是来自接收方所在包外的类（要求<b>公用</b>可视性）、来自所在包内的类（要求<b>实施</b>可视性）、来自子类（要求<b>受保护</b>可视性）、还是来自类本身或类的友元（要求<b>私有</b>可视性）。
</p>
<h4>
    <a id="Defining class operations" name="Defining class operations">定义类操作</a>
</h4>
<p>
    大部分操作是实例操作；也就是说，它们是在类的实例上执行的。但是，在某些情况下，操作适用于类的所有实例，因此是<b>类范围</b>的操作。类操作接收者实际上是<b>元类</b>的实例 － 类本身的描述 － 而不是类的任何特定实例。
    类操作的示例包括创建（实例化）新实例的消息，它们返回类的<b>所有实例</b>。
</p>
<p>
    操作字符串加下划线表示，以表明是类范围的操作。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义方法</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_method__defining_on_class" name="XE_method__defining_on_class" class="index" key="方法（method）" text="在类中定义"></a><a id="Define Methods" name="Define Methods"></a>
<p>
    方法指定操作的实施。如果操作要求的行为由操作名称、描述和参数进行了足够的定义，在许多这样的情况下，方法都是直接在编程语言中实施的。在操作的实施要求使用具体的算法或者要求比操作的描述中更多的信息，就要求有独立的<b>方法</b>描述。<b>方法</b>不仅描述操作做什么，还描述操作如何工作。
</p>
<p>
    该方法应讨论如何完成以下操作：
</p>
<ul>
    <li>
        操作将如何实施
    </li>
    <li>
        属性将如何实施以及用来实施操作
    </li>
    <li>
        关系将如何实施以及用来实施操作
    </li>
</ul>
<p>
    需求在各个案例中都不尽相同，但是类的方法规范应该总是说明：
</p>
<ul>
    <li>
        根据需求将做什么
    </li>
    <li>
        将使用什么其他对象及其操作
    </li>
</ul>
<p>
    更具体的需求可能会涉及：
</p>
<ul>
    <li>
        参数将如何实施
    </li>
    <li>
        将使用什么特殊的算法（如果有的话）
    </li>
</ul>
<p>
    时序图是这个的重要来源。从这些方面已经能很清楚地了解在执行操作时将在其他对象中使用什么操作。将在其他对象中使用什么操作的规范对于操作的完全实施是必需的。因此，生成完整的方法规范要求您确定所涉及的对象的操作并检查相应的时序图。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义状态</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_state__defining_on_classes" name="XE_state__defining_on_classes" class="index" key="状态（state）" text="在类中定义"></a><a id="Define States" name="Define States"></a> 
<p>
    对于一些操作，操作的行为取决于接收者对象所处的状态。状态机是一个工具，它描述对象可以具有的状态以及使对象从一种状态转移到另一种状态的事件（请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">技术：状态表图</a>）。状态机对于描述活动类最有用。使用状态机对于定义<img alt="" src="./../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../pages_not_installed/pages_not_installed.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">工作产品：封装体</a>的行为特别重要。
</p>
<p>
    图 2 中显示了简单状态机的示例。
</p>
<p align="center">
    <img src="./../../core.base_rup/tasks/resources/statedg.gif" width="439" height="363" alt="附带文本中描述的图。" />
</p>
<p class="picturetext">
    图 2：加油机的简单状态表图
</p>
<p>
    每个状态过渡事件都可能与操作关联。根据对象的状态，操作可能有不同的行为，转换事件描述这种情况如何发生。
</p>
<p>
    关联操作的<b>方法</b>描述应该用特定于状态的信息进行更新，表明操作对每个相关状态应该做什么。状态通常用<b>属性</b>表示；状态表图充当属性确定步骤的输入。
</p>
<p>
    有关更多信息，请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">技术：状态表图</a>。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义属性</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_attribute_on_object__defining_on_classes" name="XE_attribute_on_object__defining_on_classes" class="index" key="对象中的属性（attribute on object）" text="在类中定义"></a><a id="Define Attributes" name="Define Attributes"></a><a id="Define Attributes" name="Define Attributes"></a>
<p>
    在定义<b>方法</b>和确定<b>状态</b>期间，确定类执行其操作所需的属性。属性为类实例提供信息存储，并经常用于代表类实例的状态。类本身保持的任何信息都是通过其<b>属性</b>完成的。对于每个属性，请定义：
</p>
<ul>
    <li>
        <b>属性名</b>，它应该遵循实施语言和项目的命名约定
    </li>
    <li>
        <b>属性类型</b>，它将是实施语言支持的基本数据类型
    </li>
    <li>
        <b>属性缺省值或初始值</b>，创建类的新实例时，实例的初始化值
    </li>
    <li>
        它的<b>可视性</b>，将是下列值之一：
        <ul>
            <li>
                <b>公用</b>：在包含该类的包的内外都可以看到该属性
            </li>
            <li>
                <b>受保护</b>：属性仅对于类本身、其子类或类的友元（依赖于语言）可视
            </li>
            <li>
                <b>私有</b>：属性仅对类自身及类的友元可见
            </li>
            <li>
                <b>实施</b>：属性仅对类本身可见
            </li>
        </ul>
    </li>
    <li>
        <b>持久类</b>，属性是持久（缺省值）还是暂时的。 即使类本身可以是持久的，但并不是类的所有属性都必须是持久的
    </li>
</ul>
<p>
    检查以确保所有的属性都是需要的。属性应该有存在理由 －
    属性可以很容易在流程早期添加，并能在它们不再需要后很长时间内都存在（由于眼光短浅而造成的）。额外的属性由于数千个甚至数百万个实例而变得数量繁多，它们对系统的性能和存储需求可能有不利的影响。
</p>
<p>
    有关属性的更多信息，请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_class_E98280BF.html" guid="2.914882084937444E-305">工作产品指南：设计类</a>中题为<i>属性</i>的部分。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义依赖关系</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Dependencies" name="Define Dependencies"></a>
<p>
    对于每一个要求对象间通信的案例，请提出以下问题：
</p>
<ul>
    <li>
        对接收者的引用是作为参数传递给操作的吗？如果是的话，在包含发送者类和接收者类的类图中，在这两个类之间建立<b>依赖关系</b>。同时，如果使用了交互的<b>通信图</b>形式，那么就请使链接可视性变为合格并将其设置为<b>参数</b>。
    </li>
    <li>
        接收者是全局的吗？如果是的话，在包含发送者类和接收者类的类图中，在这两个类之间建立<b>依赖关系</b>。同时，如果使用了交互的<b>通信图</b>形式，那么就请使链接可视性变为合格并将其设置为<b>全局</b>。
    </li>
    <li>
        接收者是在操作本身过程中创建并销毁的瞬时对象吗？如果是的话，在包含发送者类和接收者类的类图中，在这两个类之间建立<b>依赖关系</b>。同时，如果使用了交互的<b>通信图</b>形式，那么就请使链接可视性变为合格并将其设置为<b>局部</b>。
    </li>
</ul>
<p>
    请注意，用这种方式建模的链接是临时链接，只在协作的特定环境中存在有限的期限 － 从这个意义上来讲，它们是协作中关联角色的实例。但是，如上文所述，类模型中的关系（即，独立于环境）应该是依赖关系。如 [<a class="elementLinkWithUserText" href="./../../core.base_rup/customcategories/references_56F06DFD.html#RUM98" guid="7.755968586980351E-308">RUM98</a>]
    中<b>暂时链接</b>的定义中所述：“可以将所有这样的链接作为关联进行建模，但是这样的话，关联的条件就必须表述得非常宽泛，而且它们在限制对象的组合时在很大程度上失去了精确性。”在这种情况下，对依赖关系建模就不如对协作中的关系建模那么重要，因为依赖关系并不完整地描述关系；而仅仅描述它存在而已。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义关联关系</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Associations" name="Define Associations"></a><a id="Define Attributes and Relationships" name="Define Attributes and Relationships"></a>
<p>
    关联向对象提供互相交流的机制。它们向对象提供消息可以流动的导管。它们还记录类之间的依赖关系，突出强调一个类中的更改可以被许多其他的类感觉到。
</p>
<p>
    检验每个操作的<b>方法</b>描述，了解类的实例如何与其他对象互相交流和协作。要将消息发送给另一个对象，对象就必须有到消息的接收者的引用。通信图（时序图的另一种表示方法）将从链接的角度显示对象通信，如图 3 所示。
</p>
<p align="center">
    <img src="./../../core.base_rup/tasks/resources/collabd.gif" width="610" height="493" alt="附带文本中描述的图。" />
</p>
<p class="picturetext">
    图 3：通信图的示例
</p>
<h4>
    <a id="Defining associations and aggregations" name="Defining associations and aggregations">定义关联关系和聚集关系</a>
</h4>
<p>
    剩下的消息用<b>关联</b>或<b>聚集</b>来指定互相交流的两个类的实例之间的关系。有关选择适当的表示方法的信息，请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/association_98710829.html" guid="5.540135518285335E-305">技术：关联关系</a>和<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/aggregation_A53E33AB.html" guid="1.1538495077622037E-304">技术：聚集关系</a>。请在通信图中将这两种关联的链接可视性都设置为<b>字段</b>。其他任务包括：
</p>
<ul>
    <li>
        建立关联和聚集的可导航性。您可以通过考虑它们在交互图上的链接实例化所要求的可导航性来执行这一操作。因为缺省的情况下，可导航性为
        <b>true</b>，所以您只要找到关联中一个类的所有对象的所有相反链接角色都不要求可导航性的关联（和聚集）就可以了。在这些情况下，请将类的角色的可导航性设置为 <b>false</b>。
    </li>
    <li>
        如果关联本身有属性（用关联类表示），请创建带有适当属性的设计类来表示关联类。将该类插入其他两个类之间，并建立关联类和其他的这两个类之间的关联，同时带有适当的多重性。
    </li>
    <li>
        指定<i>关联关系端</i>是否应该<b>排序</b>；如果与关联关系另一端相关联的对象具有必须保留的顺序，则需要确定这一点。
    </li>
    <li>
        如果关联（或聚集）类仅被当前类引用，请考虑类是否应该嵌套。嵌套类的好处包括更加快速的消息传递以及更简单的设计模型。缺点包括嵌套类占用的空间被固定分配，而不管是否有嵌套类的实例、是否缺乏独立于包含类的对象身份或者是否无法从包含类的外部引用嵌套类实例。
    </li>
</ul>
<p>
    关联和聚集在描述关联类的类图中有最好的定义。类图应该由包含关联类的程序包<b>拥有</b>。图 4 是一个描述关联和聚集的类图示例。
</p>
<p align="center">
    <img src="./../../core.base_rup/tasks/resources/classdg.gif" width="469" height="396" alt="附带文本中描述的图。" />
</p>
<p class="picturetext">
    图 4：显示类之间的关联、聚集和泛化关系的类图示例
</p>
<h4>
    <a id="Handling Subscribe-Associations between Analysis Classes" name="Handling Subscribe-Associations between Analysis Classes">处理分析类之间的预订关联关系</a>
</h4>
<p>
    <b>分析类</b>之间的预订关联关系用于确定类之间的事件依赖关系。在“设计模型”中，您必须明确地处理这些事件依赖关系，通过使用可用的事件处理程序框架或者通过设计并构造您自己的事件处理程序框架。在一些编程语言中 － 如 Visual
    Basic － 这是直接了当的；您声明、提出并处理相应的事件。在其他语言中，您可能必须使用一些其他的可重用功能库来处理预订和事件。如果功能无法购买，它就需要进行设计和构造。 另请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/subscribe-association_1AB75163.html" guid="1.401846671640991E-305">技术：预订关联</a>。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义内部结构</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Internal Structure" name="Define Internal Structure"></a>
<p>
    某些类可能表示复杂抽象并具有复杂的结构。在对类建模时，设计人员可能希望表示其内部参与元素以及它们的关系，以确保实施者将相应地实施在该类内部发生的协作。
</p>
<p>
    在 UML 2.0 中，类被定义为<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/termdefinitions/structured_class_4BB99B12.html" guid="_yW3E4NnmEdmO6L4XMImrsA">结构化类</a>，可具有内部结构和端口。然后，类可被分解成互相连接的部分的集合，而这些部分又可以进一步进行分解。可以通过强制来自外部的通信经过遵守已声明接口的端口来封装类。
</p>
<p>
    当您找到有复杂结构的复杂类时，请为该类创建复合的结构图。
    对将为该类行为执行角色的部分进行建模。确定如何使用连接器将各部分“连线”。如果要使该类的不同客户端可以访问该类提供的特定部分的行为，请利用带所声明接口的端口。同时请利用端口将该类的内部部分完整地从其环境中分离出来。
</p>
<p>
    关于本主题的更多信息以及复合结构图的示例，请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">概念：结构化类</a>。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 定义泛化关系</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Define Generalizations" name="Define Generalizations"></a>
<p>
    类可以组织为泛化关系层次结构，以反映通用的行为和通用的结构。
    可以定义公用的<b>超类</b>，<b>子类</b>可以继承超类的行为和结构。泛化关系是为了表示上的方便，使您能够在一个地方定义通用的结构和行为，并在找到重复行为和结构的地方重复使用这种通用的结构和行为。有关泛化关系的更多信息，请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/generalization_94751549.html" guid="1.839540980397304E-305">技术：泛化关系</a>。
</p>
<p>
    当您找到泛化关系时，请创建一个通用超类来包含通用属性、关联、聚集和操作。将通用行为从将成为通用超类的子类的类中除去。定义从子类到超类的<b>泛化关系</b>。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 解决用例冲突</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_concurrency_conflicts__identifying" name="XE_concurrency_conflicts__identifying" class="index" key="并行冲突（concurrency conflicts）" text="确定"></a><a id="Resolve Use-Case Collisions" name="Resolve Use-Case Collisions"></a>
<p>
    本步骤的目的是防止两个或更多个用例可能同时、用可能不一致的方式访问设计类的实例时造成的并行冲突。
</p>
<p>
    在设计流程中逐个用例地前进中存在的一个困难是：两个或更多个用例可能会尝试用可能冲突的方式同时对设计对象调用操作。在这些情况下，并行冲突必须明确地进行确定和解决。
</p>
<p>
    如果使用了同步消息传递，那么执行操作将阻止对对象的后续调用，直到操作完成为止。同步消息传递意味着消息处理的“先到先服务”的顺序。这可能会解决并行冲突，特别是当所有消息的优先级都相同或者当每条消息都在相同的执行线程内运行的时候。如果对象可能由不同的执行线程（用活动类表示）访问，就必须使用显式机制来防止或解决并行冲突。
</p>
<p class="reactive">
    在线程用<img alt="" src="./../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../pages_not_installed/pages_not_installed.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">工作产品：封装体</a>表示的实时系统中，在对被动对象有多个并发访问时，这个问题仍然必须解决，而封装体本身提供排队机制并强制使用“运行到完成”语义来处理并发访问。建议的解决方案是在封装体内封装被动对象，这就通过封装体本身的语义避免了并发访问问题。
</p>
<p>
    同一个对象上的不同操作被不同的执行线程同时调用而不出现并行冲突是可能的；客户的姓名和地址可以并行修改而不起冲突。只有当两个不同的执行线程尝试修改对象的同一个属性时，才会出现冲突。
</p>
<p>
    请为每一个可能会由不同的执行线程并行访问的对象确定必须受保护以免于同时访问的代码段。在“精化”阶段早期，确定具体的代码段是不可能的；必须受保护的操作就足够了。接着，选择或设计适当的访问控制机制来防止互相冲突的同时访问。这些机制的示例包括消息排队以将访问序列化、使用信号或标记允许一次只能访问一个线程或者其他变化形式的锁定机制。机制的选择倾向于在很大程度上取决于实施，并且一般会随着编程语言和操作环境的变化而变化。有关选择并行机制的指南，请参阅<img alt="" src="./../../images/no_rup.gif">&#160;<a class="elementLinkWithUserText" href="./../../pages_not_installed/pages_not_installed.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">特定于项目的指南</a>。
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> 处理一般的非功能需求</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="XE_nonfunctional_requirements__handling_of" name="XE_nonfunctional_requirements__handling_of" class="index" key="非功能需求（nonfunctional requirements）" text="处理"></a><a id="Handle Non-Functional Requirements" name="Handle Non-Functional Requirements"></a> 
<p>
    “设计类”被优化来处理一般的、非功能的需求。 本步骤的重要输入包括分析类的非功能需求，这些需求可能在分析类的特别需求和职责中已经有了说明。
    这样的需求往往从需要什么样的体系结构（分析）机制来实现类这一方面进行指定；在本步骤中，类然后被优化来合并与这些分析机制相对应的设计机制。
</p>
<p>
    可用的设计机制由软件设计人员确定并描述。对于每个需要的设计机制，请使尽可能多的特征合格，在适当的地方给定范围。有关设计机制的更多信息，请参阅<a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/identify_design_mechanisms_9A197FBC.html" guid="{C7A26BD7-3820-48D9-830F-684C3AF155F9}">任务：确定设计机制</a>、<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/analysis_mechanisms_36135B43.html" guid="9.76539014099254E-305">概念：分析机制</a>和<a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/design_and_implementation_mechanisms_A37EAC7D.html" guid="6.131233324119695E-305">概念：设计和实施机制</a>。
</p>
<p>
    在设计类时需要考虑数个一般的设计指南和机制，例如如何：
</p>
<ul>
    <li>
        使用现有的产品和组件
    </li>
    <li>
        适应编程语言
    </li>
    <li>
        分发对象
    </li>
    <li>
        达到可接受的性能
    </li>
    <li>
        达到某些安全级别
    </li>
    <li>
        处理错误
    </li>
</ul></td>
</tr>
</table>
</div>
<div class="stepHeading"> 评估您的结果</div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Evaluate Your Results" name="Evaluate Your Results"></a> 
<p>
    在此阶段检查设计模型来验证您的工作是否正朝着正确的方向前进。没有必要详细复审模型，但是您应该考虑以下核对表：
</p>
<ul>
    <li>
        <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/design_model_18BE347C.html" guid="1.4639852935143625E-305">设计模型</a>
    </li>
    <li>
        <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/checklists/design_class_436B6210.html" guid="1.1028389988231071E-306">设计类的核对表</a>
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">属性</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_多次出现" abbr="多次出现">多次出现</th><td align="left" class="sectionTableCell" headers="property_多次出现"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_事件驱动" abbr="事件驱动">事件驱动</th><td align="left" class="sectionTableCell" headers="property_事件驱动"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_正在进行" abbr="正在进行">正在进行</th><td align="left" class="sectionTableCell" headers="property_正在进行"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_可选" abbr="可选">可选</th><td align="left" class="sectionTableCell" headers="property_可选"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_已计划" abbr="已计划">已计划</th><td align="left" class="sectionTableCell" headers="property_已计划"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading" id="property_可重复" abbr="可重复">可重复</th><td align="left" class="sectionTableCell" headers="property_可重复"><img title="" alt="" height="15" width="20" src="./../../images/indent.gif"></td>
</tr>
</table>
</div>
<div class="sectionHeading">更多信息</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">概念</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/concepts/concurrency_EE2E011A.html" guid="3.5787175388799096E-305">并行</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">指南</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html" guid="1.4528459404144188E-304">状态表图</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/guidelines/class_diagram_B2F8A2E2.html" guid="4.2570304587974485E-305">类图</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/guidelines/aggregation_A53E33AB.html" guid="1.1538495077622037E-304">聚集</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/guidelines/association_98710829.html" guid="5.540135518285335E-305">关联</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/guidelines/subscribe-association_1AB75163.html" guid="1.401846671640991E-305">预订关联</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/guidelines/generalization_94751549.html" guid="1.839540980397304E-305">泛化关系</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/guidelines/user_interface_general_12B3C0B9.html" guid="6.780901688276357E-305">用户界面（常规）</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">工具向导</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/manage_class_E87F7860.html" guid="{234EB01D-88DF-4EBC-B806-CAA81CD2BF13}">使用 Rational Rose 管理类</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/class_design_5CE83B0A.html" guid="{D1C3F9B8-8EE3-4AF6-8E7B-0653AF1F2936}">使用 Rational XDE Developer 设计类</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;All Rights Reserved.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
					contentPage.onload();
					contentPage.processPage.fixDescriptorLinks();
				</script>
</html>
